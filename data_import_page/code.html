<!doctype html>
<html class="dark" lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Data Playground — Functional</title>

  <link href="https://fonts.googleapis.com" rel="preconnect" />
  <link crossorigin href="https://fonts.gstatic.com" rel="preconnect" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet" />

  <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>

  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: { primary: '#1173d4', 'background-light': '#f6f7f8', 'background-dark': '#101922' },
          fontFamily: { display: ['Inter'] },
          borderRadius: { DEFAULT: '0.25rem', lg: '0.5rem', xl: '0.75rem', full: '9999px' },
        },
      },
    };
  </script>

  <style>
    .material-symbols-outlined {
      font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
    }

    /* small visual for drop active */
    .drop-active {
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
      transform: translateY(-2px);
    }
  </style>
</head>

<body class="font-display bg-background-light dark:bg-background-dark">
  <div class="min-h-screen flex flex-col">
    <header
      class="sticky top-0 z-20 bg-background-light/80 dark:bg-background-dark/80 backdrop-blur-sm border-b border-black/10 dark:border-white/10">
      <div class="container mx-auto px-4 py-4">
        <h1 class="text-xl font-bold text-slate-800 dark:text-white">Data Playground</h1>
      </div>
    </header>

    <main class="flex-grow container mx-auto px-4 py-8">
      <div class="max-w-4xl mx-auto space-y-8">

        <!-- Upload -->
        <section>
          <h2 class="text-2xl font-bold text-slate-900 dark:text-white mb-4">Upload Data</h2>
          <label id="dropzone"
            class="flex flex-col items-center justify-center w-full h-48 border-2 border-slate-300 dark:border-slate-700 border-dashed rounded-lg cursor-pointer bg-slate-50 dark:bg-slate-800/20 hover:bg-slate-100 dark:hover:bg-slate-800/40 transition-colors"
            for="fileInput">
            <div class="flex flex-col items-center justify-center pt-5 pb-6">
              <span class="material-symbols-outlined text-4xl text-slate-500 dark:text-slate-400">upload_file</span>
              <p class="mb-2 text-sm text-slate-500 dark:text-slate-400"><span class="font-semibold">Click to
                  upload</span> or drag & drop</p>
              <p class="text-xs text-slate-500 dark:text-slate-400">CSV or JSON (MAX. 50MB)</p>
              <p id="drop-hint" class="text-xs text-slate-400 mt-2"></p>
            </div>
            <input id="fileInput" type="file" accept=".csv,.json,text/csv,application/json" class="hidden" />
          </label>
        </section>

        <!-- Info -->
        <div id="fileInfo" class="text-sm text-slate-600 dark:text-slate-300"></div>

        <!-- Preview -->
        <section>
          <h3 class="text-lg font-semibold text-slate-900 dark:text-white mb-4">Data Preview</h3>
          <div id="previewContainer"
            class="overflow-x-auto rounded-lg border border-black/10 dark:border-white/10 p-2 text-slate-600 dark:text-slate-300">
            <p id="previewEmpty" class="text-sm">No data uploaded yet.</p>
            <div id="preview" class="min-w-full"></div>
          </div>
        </section>

        <!-- Data Cleaning -->
        <section>
          <h3 class="text-lg font-semibold text-slate-900 dark:text-white mb-4">Data Cleaning Tools</h3>
          <div class="space-y-4">
            <div class="flex gap-2">
              <select id="renameColumn"
                class="flex-grow rounded border-slate-300 dark:border-slate-700 bg-background-light dark:bg-background-dark text-slate-900 dark:text-white">
                <option value="">Select column</option>
              </select>
              <input id="newColumnName" type="text" placeholder="New name"
                class="flex-grow rounded border-slate-300 dark:border-slate-700 bg-background-light dark:bg-background-dark text-slate-900 dark:text-white" />
              <button id="renameBtn" class="px-4 py-2 rounded bg-slate-600 text-white">Rename</button>
            </div>
            <div class="flex gap-2">
              <select id="removeColumn"
                class="flex-grow rounded border-slate-300 dark:border-slate-700 bg-background-light dark:bg-background-dark text-slate-900 dark:text-white">
                <option value="">Select column</option>
              </select>
              <button id="removeBtn" class="px-4 py-2 rounded bg-red-600 text-white">Remove</button>
            </div>
          </div>
        </section>
        <!-- Preview -->
        <section>
          <h3 class="text-lg font-semibold text-slate-900 dark:text-white mb-4">Data Preview</h3>
          <div id="previewContainer"
            class="overflow-x-auto rounded-lg border border-black/10 dark:border-white/10 p-2 text-slate-600 dark:text-slate-300">
            <p id="previewEmpty" class="text-sm">No data uploaded yet.</p>
            <div id="preview" class="min-w-full"></div>
          </div>

          <!-- Action Buttons -->
          <div class="mt-4 flex flex-row-reverse gap-2">
            <button id="analysisBtn"
              class="px-4 py-2 rounded bg-primary text-white hover:bg-blue-700 ">Analysis</button>
            <button id="clearBtn" class="px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">Remove Data</button>
          </div>
        </section>

      </div>

    </main>

  </div>

  <script>
    // state
    let tableData = [];    // array of objects
    let columns = [];      // array of column names
    const PREVIEW_MAX_ROWS = 100; // limit preview size

    // DOM
    const fileInput = document.getElementById('fileInput');
    const dropzone = document.getElementById('dropzone');
    const dropHint = document.getElementById('drop-hint');
    const fileInfo = document.getElementById('fileInfo');
    const preview = document.getElementById('preview');
    const previewEmpty = document.getElementById('previewEmpty');
    const renameSelect = document.getElementById('renameColumn');
    const removeSelect = document.getElementById('removeColumn');
    const renameBtn = document.getElementById('renameBtn');
    const removeBtn = document.getElementById('removeBtn');

    // attach listeners after DOM load
    document.addEventListener('DOMContentLoaded', () => {
      fileInput.addEventListener('change', handleFileChange);
      dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.classList.add('drop-active'); dropHint.textContent = 'Release to drop the file'; });
      dropzone.addEventListener('dragleave', e => { dropzone.classList.remove('drop-active'); dropHint.textContent = ''; });
      dropzone.addEventListener('drop', e => {
        e.preventDefault();
        dropzone.classList.remove('drop-active');
        dropHint.textContent = '';
        if (!e.dataTransfer?.files?.length) return;
        // call handler with a minimal event-like object
        handleFileChange({ target: { files: e.dataTransfer.files } });
      });

      renameBtn.addEventListener('click', renameColumn);
      removeBtn.addEventListener('click', removeColumn);
    });

    // helper: show info
    function setFileInfo(html) { fileInfo.innerHTML = html || ''; }

    // handle file select
    async function handleFileChange(e) {
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      setFileInfo(`<strong>Selected:</strong> ${escapeHtml(f.name)} — ${(f.size / 1024 | 0)} KB`);
      if (f.size > 50 * 1024 * 1024) {
        setFileInfo(`<span class="text-red-600">File too large (over 50MB).</span>`);
        return;
      }

      const ext = (f.name.split('.').pop() || '').toLowerCase();
      try {
        if (ext === 'csv' || f.type.includes('csv') || /\.csv$/i.test(f.name)) {
          await parseCSVWithPapa(f);
        } else if (ext === 'json' || f.type.includes('json') || /\.json$/i.test(f.name)) {
          await parseJSONFile(f);
        } else {
          // try CSV first, then JSON
          await parseCSVWithPapa(f).catch(() => parseJSONFile(f));
        }
      } catch (err) {
        console.error(err);
        setFileInfo(`<span class="text-red-600">Parsing error: ${escapeHtml(err.message || String(err))}</span>`);
      }
    }

    // ensure Papa is loaded (dynamic load if needed)
    function ensurePapa() {
      return new Promise((resolve, reject) => {
        if (window.Papa) return resolve(window.Papa);
        const s = document.createElement('script');
        s.src = 'https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js';
        s.onload = () => resolve(window.Papa);
        s.onerror = () => reject(new Error('Failed to load PapaParse'));
        document.head.appendChild(s);
      });
    }

    async function parseCSVWithPapa(file) {
      const Papa = await ensurePapa();
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          transformHeader: h => (h === null ? '' : String(h).trim()),
          complete: res => {
            // filter out empty rows
            const rows = Array.isArray(res.data) ? res.data.filter(r => Object.values(r || {}).some(v => v !== null && v !== '')) : [];
            if (!rows.length) {
              // sometimes CSVs are not headered, fallback to text parse
              try {
                const txt = file.text().then(txt => fallbackCsvTextParse(txt));
                // if fallback parses, it will set tableData
              } catch (e) {
                // proceed with empty
              }
            }
            tableData = rows;
            columns = Array.isArray(res.meta?.fields) && res.meta.fields.length ? res.meta.fields : deriveFieldsFromData(tableData);
            afterParse(file.name);
            resolve();
          },
          error: err => {
            console.error('PapaParse error', err);
            reject(err);
          }
        });
      });
    }

    // fallback simple CSV text parse (best-effort)
    function fallbackCsvTextParse(text) {
      const lines = text.split(/\r?\n/).filter(Boolean);
      if (!lines.length) return;
      const headers = lines[0].split(',').map(h => h.trim());
      const rows = lines.slice(1).map(line => {
        const vals = line.split(',').map(v => v.trim());
        const obj = {};
        headers.forEach((h, i) => obj[h || `col_${i}`] = vals[i] ?? '');
        return obj;
      });
      tableData = rows;
      columns = headers.length ? headers : deriveFieldsFromData(tableData);
      afterParse('parsed-text.csv');
    }

    async function parseJSONFile(file) {
      const txt = await file.text();
      let parsed = JSON.parse(txt);
      if (!parsed) throw new Error('Empty JSON');

      if (Array.isArray(parsed)) {
        // array could be objects or arrays
        if (parsed.length === 0) {
          tableData = [];
          columns = [];
        } else if (Array.isArray(parsed[0])) {
          // assume first row headers
          const headers = parsed[0].map(h => String(h));
          const rows = parsed.slice(1).map(arr => {
            const obj = {};
            headers.forEach((h, i) => obj[h] = arr[i] ?? '');
            return obj;
          });
          tableData = rows;
          columns = headers;
        } else if (typeof parsed[0] === 'object') {
          tableData = parsed;
          columns = deriveFieldsFromData(tableData);
        } else {
          // array of primitives
          tableData = parsed.map((v, i) => ({ value: v }));
          columns = ['value'];
        }
      } else if (typeof parsed === 'object') {
        // single object
        tableData = [parsed];
        columns = deriveFieldsFromData(tableData);
      } else {
        // primitive
        tableData = [{ value: parsed }];
        columns = ['value'];
      }
      afterParse(file.name);
    }

    // called after successful parse
    function afterParse(filename) {
      if (!Array.isArray(tableData)) tableData = [];
      if (!columns || !columns.length) columns = deriveFieldsFromData(tableData);
      // remove rows that are completely empty
      tableData = tableData.filter(r => Object.values(r || {}).some(v => v !== null && v !== ''));
      setFileInfo(`<strong>Loaded:</strong> ${escapeHtml(filename)} — <strong>${tableData.length}</strong> rows · <strong>${columns.length}</strong> columns`);
      renderTable();
      updateColumnSelectors();
    }

    function deriveFieldsFromData(data) {
      const s = new Set();
      (data || []).forEach(r => {
        if (typeof r === 'object' && r !== null) Object.keys(r).forEach(k => s.add(k));
      });
      return Array.from(s);
    }

    // render preview table (first PREVIEW_MAX_ROWS rows)
    function renderTable() {
      previewEmpty.style.display = (tableData && tableData.length) ? 'none' : 'block';
      if (!tableData || !tableData.length) {
        preview.innerHTML = '<p class="text-sm">No data available.</p>';
        return;
      }
      const rowsToShow = tableData.slice(0, PREVIEW_MAX_ROWS);
      const truncated = tableData.length > PREVIEW_MAX_ROWS;
      let html = `<div class="mb-2 text-xs text-slate-500">Showing ${rowsToShow.length} of ${tableData.length} rows${truncated ? ' (preview truncated)' : ''} — columns: ${columns.length}</div>`;
      html += `<table class="w-full text-sm text-left border-collapse"><thead class="bg-slate-100 dark:bg-slate-700"><tr>`;
      columns.forEach(c => {
        html += `<th class="px-3 py-2 border-b">${escapeHtml(c)}</th>`;
      });
      html += `<th class="px-3 py-2 border-b text-right">Actions</th></tr></thead><tbody>`;
      rowsToShow.forEach((row, rIdx) => {
        html += `<tr class="${rIdx % 2 === 0 ? 'bg-background-light dark:bg-background-dark' : ''}">`;
        columns.forEach(col => {
          html += `<td class="px-3 py-2 align-top border-b">${escapeHtml(String(row[col] ?? ''))}</td>`;
        });
        html += `<td class="px-3 py-2 border-b text-right"><button class="px-2 py-1 text-xs rounded bg-slate-200 dark:bg-slate-700" onclick="editRow(${rIdx})">Edit</button> <button class="px-2 py-1 text-xs rounded bg-red-200" onclick="deleteRow(${rIdx})">Delete</button></td></tr>`;
      });
      html += `</tbody></table>`;
      preview.innerHTML = html;
    }

    // small row actions (for preview rows only)
    window.editRow = function (idx) {
      const absoluteIdx = idx; // preview index maps to same index in tableData slice
      const row = tableData[absoluteIdx];
      const updated = prompt(`Edit JSON for row ${absoluteIdx} (edit the object as valid JSON):`, JSON.stringify(row, null, 2));
      if (!updated) return;
      try {
        const parsed = JSON.parse(updated);
        tableData[absoluteIdx] = parsed;
        renderTable();
      } catch (err) {
        alert('Invalid JSON. No change made.');
      }
    };

    window.deleteRow = function (idx) {
      if (!confirm('Delete this row from the dataset?')) return;
      tableData.splice(idx, 1);
      setFileInfo(`<strong>Updated rows:</strong> ${tableData.length}`);
      renderTable();
      updateColumnSelectors();
    };

    // column utilities
    function updateColumnSelectors() {
      const safeCols = columns || [];
      const makeOptions = cols => {
        return ['<option value="">Select column</option>', ...cols.map(c => `<option value="${escapeHtmlAttr(c)}">${escapeHtml(c)}</option>`)].join('');
      };
      renameSelect.innerHTML = makeOptions(safeCols);
      removeSelect.innerHTML = makeOptions(safeCols);
    }

    function renameColumn() {
      const oldName = renameSelect.value;
      const newName = document.getElementById('newColumnName').value.trim();
      if (!oldName || !newName) {
        alert('Choose a column and enter a new name.');
        return;
      }
      tableData = tableData.map(row => {
        // preserve property order: assign new then delete old
        row[newName] = row[oldName];
        delete row[oldName];
        return row;
      });
      columns = columns.map(c => c === oldName ? newName : c);
      updateColumnSelectors();
      renderTable();
      setFileInfo(`<strong>Renamed:</strong> ${escapeHtml(oldName)} → ${escapeHtml(newName)}`);
    }

    function removeColumn() {
      const col = removeSelect.value;
      if (!col) { alert('Select a column to remove'); return; }
      if (!confirm(`Remove column "${col}" from all rows?`)) return;
      tableData = tableData.map(row => { delete row[col]; return row; });
      columns = columns.filter(c => c !== col);
      updateColumnSelectors();
      renderTable();
      setFileInfo(`<strong>Removed column:</strong> ${escapeHtml(col)}`);
    }

    // small helpers
    function escapeHtml(s) { return (s + '').replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;'); }
    function escapeHtmlAttr(s) { return (s + '').replaceAll('"', '&quot;').replaceAll('&', '&amp;'); }

    // Buttons
    analysisBtn.addEventListener('click', () => {
      if (!tableData.length) {
        alert("No data to analyze!");
        return;
      }
      alert(`Analysis placeholder: You have ${tableData.length} rows and ${columns.length} columns.`);
    });

    clearBtn.addEventListener('click', () => {
      if (!tableData.length) {
        alert("No data uploaded.");
        return;
      }
      if (!confirm("Remove uploaded data?")) return;

      tableData = [];
      columns = [];
      preview.innerHTML = '';
      previewEmpty.style.display = 'block';
      setFileInfo('');
      updateColumnSelectors();
    });


    analysisBtn.addEventListener('click', () => {
      if (!tableData.length) {
        alert("No data to analyze!");
        return;
      }

      // Create a dataset object
      const dataset = {
        name: prompt("Enter dataset name:", "New Dataset") || "Untitled Dataset",
        columns: columns,
        tableData: tableData
      };

      // Save as an array of datasets in localStorage
      let savedDatasets = JSON.parse(localStorage.getItem("uploadedData"))?.datasets || [];
      savedDatasets.push(dataset);
      localStorage.setItem("uploadedData", JSON.stringify({ datasets: savedDatasets }));

      // Redirect to analysis page
      window.location.href = "../visualization_playground/code.html"; // change if needed
    });


    clearBtn.addEventListener('click', () => {
      if (!tableData.length) {
        alert("No data uploaded.");
        return;
      }
      if (!confirm("Remove uploaded data?")) return;

      tableData = [];
      columns = [];
      preview.innerHTML = '';
      previewEmpty.style.display = 'block';
      setFileInfo('');
      updateColumnSelectors();

      // also clear from localStorage
      localStorage.removeItem("uploadedData");
    });

  </script>
</body>

</html>